
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../03.data_structure/">
      
      
        <link rel="next" href="../leetcode/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.32">
    
    
      
        <title>树 - Learning Journal</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.3cba04c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
      <link rel="stylesheet" href="../../stylesheets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="Learning Journal" class="md-header__button md-logo" aria-label="Learning Journal" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Learning Journal
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              树
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Learning Journal" class="md-nav__button md-logo" aria-label="Learning Journal" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Learning Journal
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    学习笔记
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Algorithm
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Algorithm
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    算法学习计划
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../02.complexity_analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    复杂度分析 - Complexity Analysis
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../03.data_structure/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数据结构
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    树
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    树
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树遍历
    </span>
  </a>
  
    <nav class="md-nav" aria-label="二叉树遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      层序遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      前序遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      中序遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      后序遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      场景解释：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      例子分析：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      总结：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 递归的统一性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 迭代的多样性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3. 为什么递归和迭代不统一？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      4. 是否存在统一的迭代方案？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5. 递归就是栈的迭代？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      结论
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-pre-order-traversal" class="md-nav__link">
    <span class="md-ellipsis">
      1. 前序遍历（Pre-order Traversal）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-in-order-traversal" class="md-nav__link">
    <span class="md-ellipsis">
      2. 中序遍历（In-order Traversal）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-post-order-traversal-" class="md-nav__link">
    <span class="md-ellipsis">
      3. 后序遍历（Post-order Traversal）- 单栈加指针法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      总结：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      进一步掌握并理解前中后序遍历
    </span>
  </a>
  
    <nav class="md-nav" aria-label="进一步掌握并理解前中后序遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 基础题目：熟悉递归遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      2. 进阶题目：练习迭代遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    <span class="md-ellipsis">
      3. 综合应用：混合遍历和复杂树操作
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4_1" class="md-nav__link">
    <span class="md-ellipsis">
      4. 挑战题目：深入理解和掌握
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树的数组表示
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      二叉搜索树
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../leetcode/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LeetCode
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Mathematics
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Mathematics
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Mathematics/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    常用公式
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Statistics
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Statistics
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Statistics/concept/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    统计学常用概念
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Statistics/confidence_interval/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    置信区间 - Confidence Interval
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Statistics/kernel_density_estimation/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    核密度估计 - Kernel Density Estimation, KDE
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Statistics/probability_distributions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    概率分布
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Plot
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Plot
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../plot/box_plot/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    箱线图 - Box Plot
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../plot/categorical/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Visualizing categorical data
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../plot/distributions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Visualizing distributions of Data
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../plot/relationships/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    可视化统计关系 - Visualizing statistical relationships
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../plot/statistical_estimation_and_error_bars/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Statistical estimation and error bars
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树遍历
    </span>
  </a>
  
    <nav class="md-nav" aria-label="二叉树遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      层序遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      前序遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      中序遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      后序遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      场景解释：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      例子分析：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      总结：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 递归的统一性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2. 迭代的多样性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    <span class="md-ellipsis">
      3. 为什么递归和迭代不统一？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4" class="md-nav__link">
    <span class="md-ellipsis">
      4. 是否存在统一的迭代方案？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#5" class="md-nav__link">
    <span class="md-ellipsis">
      5. 递归就是栈的迭代？
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      结论
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1-pre-order-traversal" class="md-nav__link">
    <span class="md-ellipsis">
      1. 前序遍历（Pre-order Traversal）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-in-order-traversal" class="md-nav__link">
    <span class="md-ellipsis">
      2. 中序遍历（In-order Traversal）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-post-order-traversal-" class="md-nav__link">
    <span class="md-ellipsis">
      3. 后序遍历（Post-order Traversal）- 单栈加指针法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      总结：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      进一步掌握并理解前中后序遍历
    </span>
  </a>
  
    <nav class="md-nav" aria-label="进一步掌握并理解前中后序遍历">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      1. 基础题目：熟悉递归遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      2. 进阶题目：练习迭代遍历
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    <span class="md-ellipsis">
      3. 综合应用：混合遍历和复杂树操作
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4_1" class="md-nav__link">
    <span class="md-ellipsis">
      4. 挑战题目：深入理解和掌握
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      总结
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      二叉树的数组表示
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      二叉搜索树
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">树</h1>
<h2 id="_2">二叉树</h2>
<ul>
<li>完美二叉树 (perfect binary tree): 叶节点的 degree = 0, 其余所有节点的 degree = 2; 若树的高度为 <span class="arithmatex">\(h\)</span>, 则节点总数为 <span class="arithmatex">\(2^{h+1} - 1\)</span>, 呈现标准的指数级关系, 反映了自然界中常见的细胞分裂现象.</li>
<li>完全二叉树 (complete binary tree): 只有最底层的节点未被填满, 且最底层节点尽量靠左填充.</li>
<li>完满二叉树 (full binary tree): 除叶节点外, 其余所有节点都有两个子节点.</li>
<li>平衡二叉树 (balanced binary tree): 任意节点的左子树和右子树的高度差的绝对值小于等于 <span class="arithmatex">\(1\)</span>.</li>
</ul>
<h2 id="_3">二叉树遍历</h2>
<p><strong>全文摘要</strong>
本文详细介绍了二叉树的遍历方法，包括层序遍历和深度优先遍历（前序、中序、后序遍历）。文章通过代码示例和复杂度分析，阐释了每种遍历方式的实现逻辑和性能特点。</p>
<p><strong>关键段落</strong></p>
<ul>
<li><strong>二叉树遍历概述</strong>: 树是一种基于链表的数据结构，其遍历方式多样，包括层序遍历和深度优先遍历等。</li>
<li><strong>层序遍历</strong>:<ul>
<li><strong>定义</strong>: 层序遍历是一种广度优先遍历方式，从树的顶部到底部逐层访问节点。</li>
<li><strong>代码实现</strong>: 使用队列实现，代码示例展示了Python语言的实现方法。</li>
<li><strong>复杂度分析</strong>: 时间复杂度为O(n)，空间复杂度在最坏情况下为O(n)。</li>
</ul>
</li>
<li><strong>前序、中序、后序遍历</strong>:<ul>
<li><strong>定义</strong>: 这三种遍历方式都属于深度优先遍历，体现了“先走到尽头，再回溯继续”的遍历策略。</li>
<li><strong>代码实现</strong>: 通过递归实现，分别展示了前序、中序和后序遍历的Python代码示例。</li>
<li><strong>复杂度分析</strong>: 时间复杂度为O(n)，空间复杂度在最坏情况下为O(n)，当树退化为链表时递归深度达到最大。</li>
</ul>
</li>
<li><strong>递归与迭代</strong>: 提及深度优先搜索除了递归实现外，还可以通过迭代方式实现，鼓励读者自行探索。</li>
<li><strong>图示辅助理解</strong>: 文章中使用图示辅助读者理解二叉树遍历的过程，如层序遍历和深度优先遍历的工作原理。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">list_to_tree_dfs</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;递归方式转换一个列表为二叉树, 使用深度优先算法 - DFS&quot;&quot;&quot;</span>
    <span class="c1"># Base case: if the index is out of bounds or the value is None, return None</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="c1"># Create a new TreeNode with the current value from the list</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># Recursively build the left subtree</span>
    <span class="c1"># The left child is located at index 2 * i + 1 in a 0-indexed array</span>
    <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">list_to_tree_dfs</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Recursively build the right subtree</span>
    <span class="c1"># The right child is located at index 2 * i + 2 in a 0-indexed array</span>
    <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">list_to_tree_dfs</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Return the constructed tree node (root)</span>
    <span class="k">return</span> <span class="n">root</span>


<span class="k">def</span> <span class="nf">list_to_tree</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;转换列表为二叉树&quot;&quot;&quot;</span>
    <span class="c1"># Start the DFS from the root node (index 0)</span>
    <span class="k">return</span> <span class="n">list_to_tree_dfs</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>
<h3 id="_4">层序遍历</h3>
<p>使用队列 <code>deque</code> 来实现 <strong>层序遍历</strong> 也就是广度优先算法.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">level_order</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;层序遍历&quot;&quot;&quot;</span>
    <span class="c1"># 初始化一个队列, 加入根节点</span>
    <span class="n">queue</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="c1"># 初始化一个列表, 用于保存遍历节点的值</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 遍历树</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="c1"># 出队</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="c1"># 保存节点值</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="c1"># 左节点不为空, 左节点入队</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="c1"># 右节点不为空, 右节点入队</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="c1"># 返回结果</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">tree</span> <span class="o">=</span> <span class="n">list_to_tree</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;层序遍历: &quot;</span><span class="p">,</span> <span class="n">level_order</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>
</code></pre></div>
<pre><code>层序遍历:  [1, 2, 3, 4, 5, 6, 7]
</code></pre>
<h3 id="_5">前序遍历</h3>
<p>首先实现 <strong>前序</strong> 遍历, 分别用递归和迭代两种方式. 前序遍历的顺序是: 根 -&gt; 左子树 -&gt; 右子树</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">pre_order</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;递归方式实现前序遍历&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="c1"># 访问顺序: 根 -&gt; 左 -&gt; 右</span>
    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="n">pre_order</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">pre_order</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">pre_order_iter</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;迭代方式实现前序遍历&quot;&quot;&quot;</span>
    <span class="n">stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 访问顺序: 根 -&gt; 左 -&gt; 右</span>
    <span class="c1"># 入栈顺序: 根 -&gt; 右 -&gt; 左</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">pre_order</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;递归前序遍历: </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;迭代前序遍历: </span><span class="si">{</span><span class="n">pre_order_iter</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
<pre><code>递归前序遍历: [1, 2, 4, 5, 3, 6, 7]
迭代前序遍历: [1, 2, 4, 5, 3, 6, 7]
</code></pre>
<h3 id="_6">中序遍历</h3>
<ol>
<li><strong>栈的使用</strong>：</li>
<li>栈用于保存路径上的节点，确保在深入左子树时不会丢失访问根节点和右子树的机会。</li>
<li>通过栈的后进先出（LIFO）特性，确保在回溯到根节点时能够正确地处理右子树。</li>
<li><strong>中序遍历顺序</strong>：</li>
<li><strong>左 -&gt; 根 -&gt; 右</strong></li>
<li>在访问每个节点时，确保已经处理了该节点的左子树，然后再将节点值添加到结果列表中，最后处理右子树。</li>
<li><strong>双重循环的意义</strong>：</li>
<li><strong>外层循环</strong>：持续进行遍历，直到所有节点都被处理完（即 <code>current</code> 和 <code>stack</code> 均为空）。</li>
<li><strong>内层循环</strong>：负责不断深入左子树，将沿途的所有节点压入栈中。</li>
<li><strong>弹出节点并访问</strong>：</li>
<li>当无法继续向左深入时，从栈中弹出最近保存的节点，这个节点就是当前子树的根节点。访问这个节点并将其值存入结果列表。</li>
<li><strong>处理右子树</strong>：</li>
<li>在访问完根节点后，移动到右子树，继续上述过程。</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">in_order</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;递归方式实现中序遍历&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="c1"># 访问顺序: 左 -&gt; 根 -&gt; 右</span>
    <span class="n">in_order</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="n">in_order</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">in_order_iter</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;迭代的方式实现中序遍历&quot;&quot;&quot;</span>
    <span class="n">stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 初始化栈，用于追踪节点</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>  <span class="c1"># 从根节点开始遍历</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># 用于存储遍历结果</span>

    <span class="c1"># 当前节点不为空或栈不为空时，继续循环</span>
    <span class="k">while</span> <span class="n">current</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>
        <span class="c1"># 不断深入左子树，将节点压入栈中</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>

        <span class="c1"># 弹出栈顶节点，访问该节点（即当前子树的根节点）</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

        <span class="c1"># 转向右子树，准备遍历右子树</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>

    <span class="k">return</span> <span class="n">res</span>  <span class="c1"># 返回最终的遍历结果</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">in_order</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;递归中序遍历: </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;迭代中序遍历: </span><span class="si">{</span><span class="n">in_order_iter</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
<pre><code>递归中序遍历: [4, 2, 5, 1, 6, 3, 7]
迭代中序遍历: [4, 2, 5, 1, 6, 3, 7]
</code></pre>
<h3 id="_7">后序遍历</h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">post_order</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">res</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;后序遍历&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="c1"># 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span>
    <span class="n">post_order</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">)</span>
    <span class="n">post_order</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">res</span><span class="o">=</span><span class="n">res</span><span class="p">)</span>
    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</code></pre></div>
<p><strong>后序遍历 - 双栈方案</strong></p>
<ol>
<li>初始化<ul>
<li>准备两个栈，<code>stack1</code> 和 <code>stack2</code>。</li>
<li>将根节点压入 <code>stack1</code>，<code>stack2</code> 初始化为空。</li>
</ul>
</li>
<li>遍历过程<ul>
<li><strong>步骤1</strong>：从 <code>stack1</code> 中弹出一个节点，将其压入 <code>stack2</code>。</li>
<li><strong>步骤2</strong>：如果弹出的节点有左子节点，将左子节点压入 <code>stack1</code>。</li>
<li><strong>步骤3</strong>：如果弹出的节点有右子节点，将右子节点压入 <code>stack1</code>。</li>
<li><strong>步骤4</strong>：重复上述过程，直到 <code>stack1</code> 为空。此时，<code>stack2</code> 中保存的顺序就是后序遍历的逆序（因为右子树先于左子树压入 <code>stack2</code>）。</li>
</ul>
</li>
<li>构建结果<ul>
<li>从 <code>stack2</code> 中依次弹出节点，将节点的值添加到结果列表中。</li>
<li><code>stack2</code> 中的节点顺序正好是后序遍历的顺序，因此直接将它们加入结果列表即可。</li>
</ul>
</li>
<li>终止条件<ul>
<li>当 <code>stack1</code> 为空时，遍历结束。</li>
<li>最终返回结果列表。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">post_order_iter1</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;后序遍历 - 双栈方案&quot;&quot;&quot;</span>
    <span class="c1"># 主栈，用于遍历树结构</span>
    <span class="n">stack1</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 辅助栈，用于存储访问顺序</span>
    <span class="n">stack2</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 结果列表，用于存储遍历结果</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># 如果根节点为空，直接返回空列表</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># root 入主栈</span>
    <span class="n">stack1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="c1"># 迭代主栈</span>
    <span class="k">while</span> <span class="n">stack1</span><span class="p">:</span>
        <span class="c1"># 弹出栈顶节点</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack1</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="c1"># 将弹出的节点压入辅助栈</span>
        <span class="n">stack2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># 如果左子树不为空, 压入主栈</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="c1"># 如果右子树不为空, 压入主栈</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">stack1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="c1"># 迭代辅助栈，将节点值加入结果列表</span>
    <span class="k">while</span> <span class="n">stack2</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stack2</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span>
</code></pre></div>
<p><strong>后序遍历 - 单栈加指针方案</strong></p>
<ol>
<li>初始化<ul>
<li>准备一个栈 <code>stack</code> 用于追踪节点，以及一个指针 <code>current</code>，初始指向根节点。</li>
<li>另一个指针 <code>last_visited</code> 用于标记上一个访问过的节点，初始设置为 <code>None</code>。</li>
</ul>
</li>
<li>遍历过程<ul>
<li><strong>步骤1</strong>：沿着左子树不断深入，将当前节点 <code>current</code> 压入 <code>stack</code>，并将 <code>current</code> 更新为其左子节点。</li>
<li><strong>步骤2</strong>：如果 <code>current</code> 为 <code>None</code>（即已到达左子树的尽头），查看栈顶节点 <code>peek_node</code>。</li>
<li><strong>步骤3</strong>：<ul>
<li>如果 <code>peek_node</code> 有右子节点，且 <code>last_visited</code> 不等于 <code>peek_node</code> 的右子节点，说明右子树尚未访问。此时，将 <code>current</code> 更新为 <code>peek_node</code> 的右子节点，继续处理右子树。</li>
<li>如果 <code>peek_node</code> 没有右子节点，或 <code>last_visited</code> 等于 <code>peek_node</code> 的右子节点，说明右子树已经访问完毕或不存在右子树。此时可以访问栈顶节点，将其值加入结果列表，并将 <code>last_visited</code> 更新为 <code>peek_node</code>，然后将其从栈中弹出。</li>
</ul>
</li>
</ul>
</li>
<li>终止条件<ul>
<li>当 <code>stack</code> 为空且 <code>current</code> 为 <code>None</code> 时，遍历结束。</li>
<li>最终返回结果列表。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">post_order_iter2</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;后序遍历 - 单栈加指针方案&quot;&quot;&quot;</span>
    <span class="c1"># 初始化栈</span>
    <span class="n">stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 初始化当前指针, 指向根节点</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
    <span class="c1"># 初始化标记指针, 用于标记上一个访问过的节点</span>
    <span class="n">last_visited</span><span class="p">:</span> <span class="n">TreeNode</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># 初始化遍历值列表</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># 循环遍历: 当前指针不为空 或 栈不为空</span>
    <span class="k">while</span> <span class="n">current</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>
        <span class="c1"># 沿着当前节点的左子树不断深入</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="c1"># 当前节点入栈</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="c1"># 指针指向左子树</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
        <span class="c1"># 查看栈顶节点</span>
        <span class="n">peek_node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># 如果栈顶节点有右子树 且 标记指针不等于右子树. 说明右子树尚未被访问过</span>
        <span class="c1"># 此时, 将当前指针指向右子树</span>
        <span class="k">if</span> <span class="n">peek_node</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">last_visited</span> <span class="o">!=</span> <span class="n">peek_node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">peek_node</span><span class="o">.</span><span class="n">right</span>
        <span class="c1"># 如果栈顶节点没有右子树 或 标记指针等于右子树. 说明右子树已经访问完毕</span>
        <span class="c1"># 此时, 可以访问栈顶节点了, 即将其值加入结果列表, 并将标记指针指向栈顶节点</span>
        <span class="c1"># 最后将其从栈中弹出</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peek_node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">last_visited</span> <span class="o">=</span> <span class="n">peek_node</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">post_order</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;递归中序遍历: </span><span class="si">{</span><span class="n">res</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;迭代中序遍历 - 双栈方法: </span><span class="si">{</span><span class="n">post_order_iter1</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;迭代中序遍历 - 单栈加指针方法: </span><span class="si">{</span><span class="n">post_order_iter2</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
<pre><code>递归中序遍历: [4, 5, 2, 6, 7, 3, 1]
迭代中序遍历 - 双栈方法: [4, 5, 2, 6, 7, 3, 1]
迭代中序遍历 - 单栈加指针方法: [4, 5, 2, 6, 7, 3, 1]
</code></pre>
<div class="admonition question">
<p class="admonition-title">Question</p>
<p>什么时候会出现 <code>peek_node.right</code> 不为空, 且 <code>peek_node.right == last_visited</code></p>
</div>
<div class="admonition quote">
<p class="admonition-title">Quote</p>
<p>在后序遍历的迭代实现中，<code>peek_node.right</code> 不为空且 <code>peek_node.right == last_visited</code> 的情况出现在你已经完成了对当前节点的右子树的遍历，准备“访问”当前节点的时候。</p>
<h3 id="_8">场景解释：</h3>
<ol>
<li><strong>到达右子树</strong>：<ul>
<li>首先，代码沿着左子树一路深入，把每个节点压入栈。这是“到达”的过程。</li>
<li>当到达一个节点后，代码会检查该节点是否有右子树。如果有，并且右子树还没有被访问过（即 <code>last_visited != peek_node.right</code>），那么会将当前指针指向右子树，继续深入遍历。</li>
</ul>
</li>
<li><strong>遍历完右子树</strong>：<ul>
<li>右子树会被递归地遍历，当右子树的所有节点都被访问并弹出栈后，<code>last_visited</code> 会更新为刚刚访问过的右子树的根节点。</li>
<li>此时，代码回到右子树的父节点（即之前的栈顶节点）。</li>
</ul>
</li>
<li><strong>判断栈顶节点</strong>：<ul>
<li>回到父节点时，<code>peek_node</code> 依然是这个父节点。现在的情况是：<ul>
<li><code>peek_node.right</code> 不为空，表示该节点确实有右子树。</li>
<li><code>last_visited == peek_node.right</code>，表示这个右子树已经被完整访问过了。</li>
</ul>
</li>
</ul>
</li>
<li><strong>访问栈顶节点</strong>：<ul>
<li>当满足 <code>peek_node.right == last_visited</code> 的条件时，说明右子树的遍历已经完成。此时可以安全地访问父节点（即 <code>peek_node</code>），将其值记录到结果列表中，并将其从栈中弹出。</li>
</ul>
</li>
</ol>
<h3 id="_9">例子分析：</h3>
<ul>
<li>假设我们处理到节点 <code>2</code>，它的右子树是节点 <code>5</code>。</li>
<li>首先，<code>2</code> 和它的左子树（节点 <code>4</code>）会被处理。<code>4</code> 处理完毕后，代码回到节点 <code>2</code>。</li>
<li>此时，<code>peek_node</code> 为节点 <code>2</code>，<code>peek_node.right</code> 为节点 <code>5</code>，且 <code>last_visited != peek_node.right</code>，所以代码会去处理右子树 <code>5</code>。</li>
<li>当节点 <code>5</code> 被完全访问并从栈中弹出后，<code>last_visited</code> 被更新为 <code>5</code>。</li>
<li>代码再次回到节点 <code>2</code>，此时 <code>peek_node.right</code>（即节点 <code>5</code>）已经被访问过，满足 <code>peek_node.right == last_visited</code>。</li>
<li>于是，代码可以安全地访问节点 <code>2</code> 并将其弹出。</li>
</ul>
<h3 id="_10">总结：</h3>
<p><code>peek_node.right</code> 不为空且 <code>peek_node.right == last_visited</code> 出现在右子树已经被完整访问完毕的情况下。这个条件的存在确保了在后序遍历中，节点在其左右子树都被处理完成之后才被访问。</p>
</div>
<div class="admonition question">
<p class="admonition-title">Question</p>
<p>在理解前序,中序,后序遍历时我比较迷茫. 首先递归方法简洁优雅但是并不能很好的理解其内部实现逻辑, 但是三种递归代码看起来非常一致, 其访问值的位置恰好可以和他们的名字对应上, 而迭代方案就完全不同了, 他们倒是便于理解(相对而言)但是实现代码完全不同, 有没有一个类似的代码方案来实现前中后序的迭代方案?以及为什么会没有?按理递归就是栈迭代啊</p>
</div>
<div class="admonition quote">
<p class="admonition-title">Quote</p>
<p>你提出的问题非常有深度，也是很多人在学习树遍历时常常感到困惑的地方。确实，递归方法与迭代方法在表现形式上有很大差异，特别是在前序、中序和后序遍历的迭代实现上。</p>
<h3 id="1">1. <strong>递归的统一性</strong></h3>
<p>递归的本质是利用函数调用栈来管理遍历的状态，因此对于前序、中序和后序遍历，递归实现的代码结构非常一致。递归的核心在于自然地分解问题，并通过调用栈来自动管理回溯过程，这使得递归代码看起来简洁、优雅且统一。</p>
<h3 id="2">2. <strong>迭代的多样性</strong></h3>
<p>迭代方法则不同。因为迭代实现必须显式地管理遍历状态，无法依赖函数调用栈来自动处理，因此需要根据不同的遍历顺序（前序、中序、后序）手动调整栈的操作和处理顺序。这导致了三种遍历方式在迭代实现上的代码差异：</p>
<ul>
<li>
<p><strong>前序遍历</strong>：先访问根节点，然后处理左子树和右子树。因此，栈的操作顺序是“根 -&gt; 右 -&gt; 左”，以确保在弹出时先处理左子树。</p>
</li>
<li>
<p><strong>中序遍历</strong>：要求在访问根节点前，先完成左子树的遍历，因此需要一种机制来追踪回溯到根节点后再处理右子树。</p>
</li>
<li>
<p><strong>后序遍历</strong>：在访问根节点前，必须确保左右子树都已访问。因此，最复杂，需要特别的标记或辅助结构来确保在正确的时间点访问根节点。</p>
</li>
</ul>
<h3 id="3">3. <strong>为什么递归和迭代不统一？</strong></h3>
<p>递归的“统一性”来自于它依赖的调用栈，这个调用栈自动管理了遍历过程中的“回溯”行为，而你并不需要手动管理这些状态。对于每一个递归调用，函数进入时就会顺序地进行前序、中序、或后序的访问。对于不同的遍历顺序，只需要调整访问的顺序（先根节点还是先左右子树），代码看起来就非常相似。</p>
<p>迭代方法则不同，因为你必须手动管理栈的状态，而不同的遍历顺序需要不同的栈操作和条件判断。比如，在中序遍历中，你必须在访问根节点前确定左子树已经遍历完成；在后序遍历中，你必须确定右子树和左子树都已遍历完成。</p>
<h3 id="4">4. <strong>是否存在统一的迭代方案？</strong></h3>
<p>理论上，确实可以找到一种统一的迭代方案，它可以通过改变顺序或增加标记来适应不同的遍历顺序。一个常见的做法是利用一个栈和一个标志位（或辅助结构），通过调整访问顺序和条件来模拟前序、中序和后序遍历。这种方法虽然可以在同一套代码中实现不同的遍历方式，但其实现会更加复杂，可能失去迭代方式的直观性和简洁性。</p>
<h3 id="5">5. <strong>递归就是栈的迭代？</strong></h3>
<p>你是对的，递归确实可以看作是一种隐式的栈迭代过程。但在递归中，函数调用栈自动处理了很多复杂的状态管理工作，如回溯等，而在显式的迭代中，这些工作需要手动完成。因此，递归实现看起来简洁一致，而迭代实现则需要在代码中手动管理这些状态，导致代码复杂度和形式上的差异。</p>
<h3 id="_11">结论</h3>
<ul>
<li><strong>递归实现</strong>：通过调用栈自动管理状态，适用于简单、统一的代码实现。</li>
<li><strong>迭代实现</strong>：需要手动管理状态，针对不同的遍历顺序，栈操作和条件判断有所不同，因此代码形式不统一。</li>
</ul>
<p>虽然可以找到统一的迭代方案，但这种方案可能会使代码变得更加复杂和不直观。因此，通常在实际编程中，我们更倾向于为每种遍历选择最适合的迭代实现方式。</p>
</div>
<div class="admonition question">
<p class="admonition-title">Question</p>
<p>我们用"到达过"表示已入栈节点, "访问过"表示已经出站节点来对前, 中, 后序的迭代方法做个对比总结, 其中后序遍历使用单栈加指针方法</p>
</div>
<div class="admonition quote">
<p class="admonition-title">Quote</p>
<p>我们可以通过"到达过"和"访问过"这两个术语来对比总结前序遍历、中序遍历和后序遍历的迭代实现方式。以下是对比总结：</p>
<h3 id="1-pre-order-traversal">1. 前序遍历（Pre-order Traversal）</h3>
<p><strong>遍历顺序</strong>：根 -&gt; 左 -&gt; 右</p>
<p><strong>迭代方法</strong>：</p>
<ul>
<li><strong>到达过</strong>：将当前节点压入栈，并立即访问它，即将其值写入结果列表。</li>
<li><strong>访问过</strong>：当节点的值被记录在结果列表中后，该节点被标记为访问过，然后根据需要继续深入左子树或右子树。如果左子树存在，则继续将左子树压入栈；如果左子树不存在且右子树存在，则继续处理右子树。</li>
</ul>
<p><strong>过程</strong>：</p>
<ol>
<li>初始将根节点压入栈。</li>
<li>弹出栈顶节点并访问该节点。</li>
<li>如果该节点有右子树，先将右子树压入栈；然后将左子树压入栈。</li>
<li>重复直到栈为空。</li>
</ol>
<p><strong>特点</strong>：</p>
<ul>
<li>在节点"到达"的同时立即"访问"。</li>
</ul>
<h3 id="2-in-order-traversal">2. 中序遍历（In-order Traversal）</h3>
<p><strong>遍历顺序</strong>：左 -&gt; 根 -&gt; 右</p>
<p><strong>迭代方法</strong>：</p>
<ul>
<li><strong>到达过</strong>：将当前节点压入栈，但暂不访问它，继续沿着左子树深入，直到到达最左子节点。</li>
<li><strong>访问过</strong>：从栈中弹出节点并访问它，随后如果该节点有右子树，则转向右子树，继续同样的过程。</li>
</ul>
<p><strong>过程</strong>：</p>
<ol>
<li>初始将根节点不断压入栈，沿左子树深入。</li>
<li>到达最左子节点后，从栈中弹出节点并访问。</li>
<li>如果弹出节点有右子树，则将右子树的节点压入栈，并继续沿着右子树的左子树深入。</li>
<li>重复直到栈为空。</li>
</ol>
<p><strong>特点</strong>：</p>
<ul>
<li>左子树的节点被"到达过"但未被"访问"，直到没有更左的节点时，才开始"访问"。</li>
</ul>
<h3 id="3-post-order-traversal-">3. 后序遍历（Post-order Traversal）- 单栈加指针法</h3>
<p><strong>遍历顺序</strong>：左 -&gt; 右 -&gt; 根</p>
<p><strong>迭代方法</strong>：</p>
<ul>
<li><strong>到达过</strong>：将当前节点压入栈，沿左子树深入，直到无法再深入。</li>
<li><strong>访问过</strong>：弹出栈顶节点的条件是它没有右子树或右子树已经被"访问过"。即：当节点的右子树已经被处理完成后，才能访问该节点。</li>
</ul>
<p><strong>过程</strong>：</p>
<ol>
<li>初始将根节点不断压入栈，沿左子树深入。</li>
<li>当无法再深入时，查看栈顶节点：<ul>
<li>如果栈顶节点有右子树且右子树未被"访问过"，则转向右子树。</li>
<li>如果栈顶节点没有右子树或右子树已经被"访问过"，则访问栈顶节点并将其弹出。</li>
</ul>
</li>
<li>更新<code>last_visited</code>指针为刚刚"访问过"的节点，以便判断右子树是否已被处理。</li>
<li>重复直到栈为空。</li>
</ol>
<p><strong>特点</strong>：</p>
<ul>
<li>左右子树都必须被"访问过"之后，才能"访问"根节点。</li>
<li><code>last_visited</code>指针的存在用于判断右子树是否已被访问过。</li>
</ul>
<h3 id="_12">总结：</h3>
<ul>
<li><strong>前序遍历</strong>：节点在"到达"的同时被"访问"。处理顺序为根 -&gt; 左 -&gt; 右。</li>
<li><strong>中序遍历</strong>：节点先被"到达"（入栈），只有在左子树处理完成后才会被"访问"。处理顺序为左 -&gt; 根 -&gt; 右。</li>
<li><strong>后序遍历</strong>：节点先被"到达"（入栈），必须等到左右子树都被"访问"后才会被"访问"。处理顺序为左 -&gt; 右 -&gt; 根。</li>
</ul>
<p>通过以上对比，可以清晰地看到不同遍历方式在处理节点的时机上存在的差异。希望这个总结能帮助你更好地理解三种遍历方式的实现与区别。    </p>
</div>
<h3 id="_13">进一步掌握并理解前中后序遍历</h3>
<p>以下是从简单到困难的 LeetCode 题目推荐，专注于帮助你彻底掌握二叉树的前序、中序、和后序遍历。这些题目按难度逐步递进，涵盖了递归和迭代实现的各种情况。</p>
<h4 id="1_1">1. <strong>基础题目：熟悉递归遍历</strong></h4>
<p>这些题目帮助你熟悉二叉树的基本遍历方法，主要是递归实现。</p>
<ul>
<li>
<p><strong><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">LeetCode 94: Binary Tree Inorder Traversal (中序遍历)</a></strong><br />
  这个题目要求实现二叉树的中序遍历。建议先用递归实现，然后尝试迭代方法。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">LeetCode 144: Binary Tree Preorder Traversal (前序遍历)</a></strong><br />
  要求实现二叉树的前序遍历。与中序遍历类似，先用递归再用迭代。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">LeetCode 145: Binary Tree Postorder Traversal (后序遍历)</a></strong><br />
  实现后序遍历。先熟悉递归方式，再尝试迭代方法。这个题目是后序遍历的基本入门。</p>
</li>
</ul>
<h4 id="2_1">2. <strong>进阶题目：练习迭代遍历</strong></h4>
<p>这些题目逐渐增加难度，要求你掌握迭代实现和结合不同遍历方式的应用。</p>
<ul>
<li>
<p><strong><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">LeetCode 102: Binary Tree Level Order Traversal (层序遍历)</a></strong><br />
  这个题目涉及二叉树的层序遍历，虽然与前中后序遍历不同，但可以帮助你理解树的遍历结构。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/same-tree/">LeetCode 100: Same Tree</a></strong><br />
  这个题目通过前序遍历来判断两棵树是否相同，递归实现非常自然，之后可以尝试迭代方式。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/symmetric-tree/">LeetCode 101: Symmetric Tree</a></strong><br />
  使用递归（通常是后序遍历）判断一棵树是否对称。掌握递归后，可以尝试用栈或队列进行迭代实现。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/path-sum/">LeetCode 112: Path Sum</a></strong><br />
  这个题目要求判断是否存在一条从根到叶子的路径，其节点值之和等于给定的值。可以通过前序遍历递归实现，也可以通过迭代方法来完成。</p>
</li>
</ul>
<h4 id="3_1">3. <strong>综合应用：混合遍历和复杂树操作</strong></h4>
<p>这些题目更复杂，涉及混合遍历、树的改造和深度操作。</p>
<ul>
<li>
<p><strong><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">LeetCode 230: Kth Smallest Element in a BST</a></strong><br />
  通过中序遍历找到二叉搜索树中的第 k 小元素。可以结合栈进行迭代实现。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">LeetCode 103: Binary Tree Zigzag Level Order Traversal</a></strong><br />
  这个题目要求你用层序遍历的变种实现“之字形”遍历，结合队列和栈的使用。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236: Lowest Common Ancestor of a Binary Tree</a></strong><br />
  这个题目要求找到二叉树中两个节点的最低公共祖先。需要用后序遍历结合递归或栈来解决。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105: Construct Binary Tree from Preorder and Inorder Traversal</a></strong><br />
  通过前序和中序遍历的结果重建二叉树。这个题目需要深入理解前序和中序遍历的特性。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/">LeetCode 297: Serialize and Deserialize Binary Tree</a></strong><br />
  实现二叉树的序列化和反序列化。这个题目综合应用了各种遍历方式，并且需要处理复杂的树结构。</p>
</li>
</ul>
<h4 id="4_1">4. <strong>挑战题目：深入理解和掌握</strong></h4>
<p>这些题目难度较大，适合在掌握了基础和进阶题目后挑战。</p>
<ul>
<li>
<p><strong><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">LeetCode 124: Binary Tree Maximum Path Sum</a></strong><br />
  找到二叉树中路径和最大的路径，涉及后序遍历的递归和回溯。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">LeetCode 889: Construct Binary Tree from Preorder and Postorder Traversal</a></strong><br />
  通过前序和后序遍历结果重建二叉树，这个题目难度较大，需要对遍历顺序有深入理解。</p>
</li>
<li>
<p><strong><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/">LeetCode 987: Vertical Order Traversal of a Binary Tree</a></strong><br />
  这个题目要求按垂直顺序遍历二叉树，需要你灵活运用多种遍历方式。</p>
</li>
</ul>
<h3 id="_14">总结</h3>
<ul>
<li><strong>从简单到复杂</strong>：先掌握递归，然后逐步过渡到迭代实现，再挑战复杂的树结构操作。</li>
<li><strong>多样化练习</strong>：在前中后序遍历基础上，多做结合这些遍历方式的题目，逐步深入理解。</li>
<li><strong>逐步掌握迭代</strong>：通过不断练习和总结，提升你对栈操作和递归模拟的理解。</li>
</ul>
<p>通过这些有针对性的题目练习，你会逐渐掌握二叉树的遍历方法，无论是递归还是迭代，都能够灵活应对。</p>
<h2 id="_15">二叉树的数组表示</h2>
<p><strong>全文摘要</strong></p>
<p>本文详细介绍了二叉树的数组表示方法，包括完美二叉树和任意二叉树的表示方式，以及完全二叉树的特殊情况。文中还提供了Python代码示例，展示了基于数组表示的二叉树类及其操作，如节点访问、遍历等。最后，文章讨论了数组表示的优点和局限性。</p>
<p><strong>关键段落</strong>
- <strong>二叉树的数组表示</strong>: 探讨了使用数组来表示二叉树的可能性，包括完美二叉树的层序遍历索引映射，以及任意二叉树通过显式None表示空位的方法。
- <strong>完美二叉树的数组表示</strong>: 描述了完美二叉树节点与数组索引的直接映射关系，以及如何通过映射公式访问子节点。数组索引与节点关系的 "映射公式": <strong>若某节点的索引为</strong> <span class="arithmatex">\(i\)</span>, <strong>则该节点的左子结点索引为</strong> <span class="arithmatex">\(2i + 1\)</span>, <strong>右子节点的索引为</strong> <span class="arithmatex">\(2i + 2\)</span>.
- <strong>任意二叉树的数组表示</strong>: 解释了非完美二叉树的层序遍历序列可能对应多种结构的问题，以及通过在序列中加入None来唯一表示二叉树的方法。
- <strong>完全二叉树的优势</strong>: 讨论了完全二叉树适合数组表示的原因，即None只出现在最底层且靠右的位置，可以省略存储所有None。
- <strong>二叉树类操作示例</strong>: 提供了Python代码示例，展示了如何实现基于数组的二叉树类，包括节点值获取、子节点索引获取、遍历方法等。
- <strong>数组表示的优缺点</strong>: 总结了数组表示二叉树的优点，如缓存友好、节省空间、随机访问节点，以及局限性，如需要连续内存空间、增删节点效率低、空间利用率低。</p>
<h2 id="_16">二叉搜索树</h2>
<p>Binary Search Tree, BST 二叉搜索树满足以下条件:</p>
<ol>
<li>对于根节点, 左子树中所有节点的值 <span class="arithmatex">\(\lt\)</span> 根节点的值 <span class="arithmatex">\(\lt\)</span> 右子树中所有节点的值</li>
<li>任意节点的左右子树也是二叉搜索树, 即同样满足条件 <span class="arithmatex">\(1\)</span></li>
</ol>
<div class="highlight"><pre><span></span><code>
</code></pre></div>
<div class="highlight"><pre><span></span><code>
</code></pre></div>
<div class="highlight"><pre><span></span><code>
</code></pre></div>
<div class="highlight"><pre><span></span><code>
</code></pre></div>
<div class="highlight"><pre><span></span><code>
</code></pre></div>
<div class="highlight"><pre><span></span><code>
</code></pre></div>
<div class="highlight"><pre><span></span><code>
</code></pre></div>
<div class="highlight"><pre><span></span><code>
</code></pre></div>
<div class="highlight"><pre><span></span><code>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.471ce7a9.min.js"></script>
      
        <script src="../../javascripts/katex.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>